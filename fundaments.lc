zero := fn f => fn a => a;

fst := fn f => fn a => f;
snd := zero;

true := fst;
false := snd;

succ := fn n => fn f => fn a => f (n f a);

one := succ zero;

plus := fn n => fn m => m succ n;
times := fn n => fn m => m n;
power := fn n => fn m => n times m one;


pair := fn t => fn e => fn c => c t e;

pred := fn n => fst(n (fn p => (pair (snd p) (succ (snd p)))) (pair zero zero));

minus := fn n => fn m => m pred n;

is_zero := fn n => n false true;

less := fn n => fn m => is_zero (minus n (pred m));


and := fn x => fn y => x (y true false) false;
not := fn c => c false true;

equal := fn n => fn m => and (is_zero (minus n m)) (not (less n m));
equal := fn n => fn m => and (less (pred n) m) (less n (pred m));
equal := fn n => fn m => and (not (less n m)) (not (less m n));

fibbit := fn n => fst (n (fn p => (pair (snd p) (plus (fst p) (snd p)))) (pair zero one));

div2 := fn n => fst (n (fn p => (pair (snd p) succ(fst p))) (pair zero zero));
